unlink('Week3_notebookspractice_cache', recursive = TRUE)
unlink('Week3_notebookspractice_cache', recursive = TRUE)
getwd()
setwd("~/.git/STAT419")
library(tinytex)
getwd()
setwd("~/.git/STAT419/WEEK-05")
chicago.willis.latlong = c(41.8791064,-87.6353986);
chicago.cloud.gate.latlong = c(41.8826213,-87.6234554);
chicago.lincoln.zoo.latlong = c(41.9217771,-87.6355701);
chicago.marriott.latlong = c(41.8920961,-87.6244929);
chicago.searle.latlong = c(41.8966098,-87.6175966);
chicago = as.data.frame( matrix( c(  chicago.willis.latlong,
chicago.cloud.gate.latlong,
chicago.lincoln.zoo.latlong,
chicago.marriott.latlong,
chicago.searle.latlong
)
,ncol=2,byrow=TRUE) );
rownames(chicago) = c("Willis Tower", "Cloud Gate", "Lincoln Zoo", "Marriott", "Searle NW");
colnames(chicago) = c("latitude","longitude");
chicago;
dist(chicago, method="manhattan", diag=FALSE, upper=TRUE);
chicago$x.lat = chicago$latitude*latitude.factor;
# how many miles is 1 degree of latitude
latitude.factor = 69;  # rough mile estimate  # 68.703 ?
chicago$x.lat = chicago$latitude*latitude.factor;
# how many miles is 1 degree of longitude
longitude.factor = 54.6;  # rough mile estimate
chicago$y.lat = chicago$longitude*longitude.factor;
chicago;
dist(chicago[,3:4], method="manhattan", diag=FALSE, upper=TRUE);
dist(chicago[,3:4], method="euclidean", diag=FALSE, upper=TRUE);
dist(chicago[,3:4], method="maximum", diag=FALSE, upper=TRUE);
dist(chicago[,3:4], method="minkowski", diag=FALSE, upper=TRUE);
# same result, different package with more distance features
library(philentropy); #install.packages("philentropy", dependencies=TRUE);
distance(chicago[,3:4], method="euclidean", diag=FALSE, upper=TRUE);
distance(chicago[,3:4], method="canberra", diag=FALSE, upper=TRUE);
getDistMethods();  # lot's of methods, some with their own parameters ..
##################################
library(geosphere);  #install.packages("geosphere", dependencies=TRUE);
# Haversine formula is robust "crow-flies"
distm( chicago[,2:1], fun=distHaversine);  # form is "long,lat" so reverse
distm( chicago[,2:1], fun=distMeeus);  # form is "long,lat" so reverse
distm( chicago[,2:1], fun=distGeo);  # form is "long,lat" so reverse
# default unit is meters, so let's convert
library(measurements); #install.packages("measurements", dependencies=TRUE);
conv_unit(2.54, "cm", "inch");
conv_unit(  distm( chicago[,2:1], fun=distHaversine),  "m", "mi"); # meters to miles
conv_unit(  distm( chicago[,2:1], fun=distMeeus),  "m", "mi"); # meters to miles
conv_unit(  distm( chicago[,2:1], fun=distGeo),  "m", "mi"); # meters to miles
nyc.timesquare.latlong = c(40.7578705,-73.9854185);
nyc.bull.wallstreet.latlong = c(40.705575,-74.0134097);
nyc.lincoln.center.latlong = c(40.772, -73.9847);
nyc.macys.latlong = c(40.7510547,-73.9904135);
nyc.broadway.latlong = c(40.7593527,-73.9870634);
nyc.stpatricks.latlong = c(40.758611, -73.976389);
nyc.best.pizza.latlong = c(40.6250931,-73.9616134);
nyc.best.cupcakes.latlong = c(40.7301048,-74.0026878);
nyc.saks.latlong = c(40.7582027,-73.9772205);
nyc = as.data.frame( matrix( c(  nyc.timesquare.latlong,
nyc.bull.wallstreet.latlong,
nyc.lincoln.center.latlong,
nyc.macys.latlong,
nyc.broadway.latlong,
nyc.stpatricks.latlong,
nyc.best.pizza.latlong,
nyc.best.cupcakes.latlong,
nyc.saks.latlong
)
,ncol=2,byrow=TRUE) );
rownames(nyc) = c("Times Square", "The Bull on WallStreet", "The Lincoln Center", "Macy's", "Broadway (Les Miserable)", "St. Patrick's", "Di Fara Pizza", "Molly's Cupcakes", "Saks 5th Avenue");
colnames(nyc) = c("latitude","longitude");
nyc;
dist(nyc, method="manhattan", diag=FALSE, upper=TRUE);
dist(nyc, method="manhattan", diag=T, upper=TRUE);
dist(nyc, method="manhattan", diag=F, upper=TRUE);
dist(nyc, method="manhattan", diag=T, upper=TRUE);
dist(nyc, method="manhattan", diag=F, upper=TRUE);
dist(nyc[,3:4], method="euclidean", diag=FALSE, upper=TRUE);
View(chicago)
View(nyc)
View(chicago)
nyc$x.lat = nyc$latitude*latitude.factor;
nyc$y.lat = nyc$longitude*longitude.factor;
nyc;
dist(nyc[,3:4], method="manhattan", diag=FALSE, upper=TRUE);
conv_unit(  distm( nyc[,2:1], fun=distHaversine),  "m", "mi"); # meters to miles
nyc;
# Haversine formula is robust "crow-flies"
distm( chicago[,2:1], fun=distHaversine);  # form is "long,lat" so reverse
distm( chicago[,2:1], fun=distMeeus);  # form is "long,lat" so reverse
distm( chicago[,2:1], fun=distGeo);  # form is "long,lat" so reverse
Sys.setenv(WSU_SANDBOX_HOST = "md5.mshaffer.com");
Sys.setenv(WSU_SANDBOX_DATABASE = "wsu_sandbox_db");
Sys.setenv(WSU_SANDBOX_USER = "wsu_sandox_user");
Sys.setenv(WSU_SANDBOX_PASSWD = "!WSUCougars");
mysql.connection = dbConnect(RMySQL::MySQL(),
user = db.user,
password = db.passwd,
dbname = db.name ,
host = db.host);
## This is set from the command console ... the one line of code is in the dropbox called "db
library(RMySQL); # install.packages("RMySQL", dependencies=TRUE);
mysql.connection = dbConnect(RMySQL::MySQL(),
user = db.user,
password = db.passwd,
dbname = db.name ,
host = db.host);
db.table.zipcodes = "zipcodes";
Sys.setenv(WSU_SANDBOX_HOST = "md5.mshaffer.com");
Sys.setenv(WSU_SANDBOX_DATABASE = "wsu_sandbox_db");
Sys.setenv(WSU_SANDBOX_USER = "wsu_sandox_user");
Sys.setenv(WSU_SANDBOX_PASSWD = "!WSUCougars");
db.host = Sys.setenv(WSU_SANDBOX_HOST = "md5.mshaffer.com");
db.name = Sys.setenv(WSU_SANDBOX_DATABASE = "wsu_sandbox_db");
db.user = Sys.setenv(WSU_SANDBOX_USER = "wsu_sandox_user");
db.passwd = Sys.setenv(WSU_SANDBOX_PASSWD = "!WSUCougars");
mysql.connection = dbConnect(RMySQL::MySQL(),
user = db.user,
password = db.passwd,
dbname = db.name ,
host = db.host);
mysql.connection = dbConnect(RMySQL::MySQL(),
user = db.user,
password = db.passwd,
dbname = db.name ,
host = db.host);
db.name <- Sys.setenv(WSU_SANDBOX_DATABASE = "wsu_sandbox_db");
mysql.connection = dbConnect(RMySQL::MySQL(),
user = db.user,
password = db.passwd,
dbname = db.name,
host = db.host);
db.host = Sys.setenv("md5.mshaffer.com");
## This is set from the command console ... the one line of code is in the dropbox called "db
library(RMySQL); # install.packages("RMySQL", dependencies=TRUE);
mysql.connection = dbConnect(RMySQL::MySQL(),
user = db.user,
password = db.passwd,
dbname = db.name,
host = db.host);
zipcode = '99163';  # CANADA allows strings for zipcodes, I removed, so only U.S.
db.table.zipcodes = "zipcodes";
zipcode = '99163';  # CANADA allows strings for zipcodes, I removed, so only U.S.
mysql.query.template = "SELECT * FROM {tablename} WHERE zipcode = '{zipcode}';";
mysql.query = gsub("{tablename}",db.table.zipcodes, mysql.query.template, fixed=TRUE);
mysql.query = gsub("{zipcode}",zipcode, mysql.query, fixed=TRUE);
mysql.query;
#result = dbSendQuery(mysql.connection, mysql.query);
result = dbGetQuery(mysql.connection, mysql.query);
db.host   = Sys.getenv("WSU_SANDBOX_HOST");
db.name   = Sys.getenv("WSU_SANDBOX_DATABASE");
db.user   = Sys.getenv("WSU_SANDBOX_USER");
db.passwd = Sys.getenv("WSU_SANDBOX_PASSWD");
mysql.connection = dbConnect(RMySQL::MySQL(),
user = db.user,
password = db.passwd,
dbname = db.name,
host = db.host);
db.table.zipcodes = "zipcodes";
zipcode = '99163';  # CANADA allows strings for zipcodes, I removed, so only U.S.
mysql.query.template = "SELECT * FROM {tablename} WHERE zipcode = '{zipcode}';";
mysql.query = gsub("{tablename}",db.table.zipcodes, mysql.query.template, fixed=TRUE);
mysql.query = gsub("{zipcode}",zipcode, mysql.query, fixed=TRUE);
mysql.query;
#result = dbSendQuery(mysql.connection, mysql.query);
result = dbGetQuery(mysql.connection, mysql.query);
result;
mysql.query;
result;
# these functions don't exist in R?
deg2rad = function(degrees)
{
degrees * (pi/180);
}
rad2deg = function(radians )
{
radians * (180/pi);
}
radius.miles = 10;
# let's build a box
my.latitude = result$latitude[1];
my.longitude = result$longitude[1];
delta.latitude = radius.miles / 68.703 ;
delta.longitude = radius.miles / (69.172 * cos(deg2rad(my.longitude)));
# 4 sides of the square ... CREATE A BOUNDING BOX
latitude.lower = my.latitude - delta.latitude;
latitude.upper = my.latitude + delta.latitude;
longitude.lower = my.longitude - delta.longitude;
longitude.upper = my.longitude + delta.longitude;
## longitude signs are opposite of latitude, would that be different outside US?
mysql.query.template = "SELECT * FROM {tablename} WHERE latitude > {latitude.lower} AND latitude < {latitude.upper} AND longitude < {longitude.lower} AND longitude > {longitude.upper} ORDER BY zipcode ASC;";
mysql.query = gsub("{tablename}",db.table.zipcodes, mysql.query.template, fixed=TRUE);
mysql.query = gsub("{zipcode}",zipcode, mysql.query, fixed=TRUE);
mysql.query = gsub("{latitude.lower}",latitude.lower, mysql.query, fixed=TRUE);
mysql.query = gsub("{latitude.upper}",latitude.upper, mysql.query, fixed=TRUE);
mysql.query = gsub("{longitude.lower}",longitude.lower, mysql.query, fixed=TRUE);
mysql.query = gsub("{longitude.upper}",longitude.upper, mysql.query, fixed=TRUE);
View(result)
latitude.lower = my.latitude - delta.latitude;
latitude.upper = my.latitude + delta.latitude;
longitude.lower = my.longitude - delta.longitude;
longitude.upper = my.longitude + delta.longitude;
## longitude signs are opposite of latitude, would that be different outside US?
mysql.query.template = "SELECT * FROM {tablename} WHERE latitude > {latitude.lower} AND latitude < {latitude.upper} AND longitude < {longitude.lower} AND longitude > {longitude.upper} ORDER BY zipcode ASC;";
mysql.query = gsub("{tablename}",db.table.zipcodes, mysql.query.template, fixed=TRUE);
mysql.query = gsub("{zipcode}",zipcode, mysql.query, fixed=TRUE);
mysql.query = gsub("{latitude.lower}",latitude.lower, mysql.query, fixed=TRUE);
mysql.query = gsub("{latitude.upper}",latitude.upper, mysql.query, fixed=TRUE);
mysql.query = gsub("{longitude.lower}",longitude.lower, mysql.query, fixed=TRUE);
mysql.query = gsub("{longitude.upper}",longitude.upper, mysql.query, fixed=TRUE);
mysql.query;
mysql.connection = dbConnect(RMySQL::MySQL(),
user = db.user,
password = db.passwd,
dbname = db.name ,
host = db.host);
result.neighbors = dbGetQuery(mysql.connection, mysql.query);
result.neighbors;
View(chicago)
View(result)
conv_unit(  distm( x = result.neighbors[, 3:2], y = result[,3:2], fun=distGeo),  "m", "mi"); # meters to miles
result.neighbors$distance <- conv_unit(  distm( x = result.neighbors[, 3:2], y = result[,3:2], fun=distGeo),  "m", "mi"); # meters to miles
result.neighbors$incircle <- isTRUE(result.neighbors$distance<= 10)
View(result.neighbors)
result.neighbors$incircle <- isTRUE(result.neighbors$distance =< 10)
result.neighbors$incircle <- isTRUE(result.neighbors$distance <= 10)
result.neighbors$incircle <- isTRUE(result.neighbors$distance <= 10.00)
View(result.neighbors)
str(result.neighbors)
result.neighbors <- result.neighbors %>% mutate(incircle = ifelse(distance > 10, FALSE, TRUE))
library(tidyverse)
result.neighbors <- result.neighbors %>% mutate(incircle = ifelse(distance > 10, FALSE, TRUE))
View(result.neighbors)
View(result.neighbors)
result.neighbors
zipcode = '84102';  # CANADA allows strings for zipcodes, I removed, so only U.S.
mysql.query.template = "SELECT * FROM {tablename} WHERE zipcode = '{zipcode}';";
mysql.query = gsub("{tablename}",db.table.zipcodes, mysql.query.template, fixed=TRUE);
mysql.query = gsub("{zipcode}",zipcode, mysql.query, fixed=TRUE);
mysql.query;
#result = dbSendQuery(mysql.connection, mysql.query);
result = dbGetQuery(mysql.connection, mysql.query);
mysql.connection = dbConnect(RMySQL::MySQL(),
user = db.user,
password = db.passwd,
dbname = db.name,
host = db.host);
zipcode = '84102';  # CANADA allows strings for zipcodes, I removed, so only U.S.
mysql.query.template = "SELECT * FROM {tablename} WHERE zipcode = '{zipcode}';";
mysql.query = gsub("{tablename}",db.table.zipcodes, mysql.query.template, fixed=TRUE);
mysql.query = gsub("{zipcode}",zipcode, mysql.query, fixed=TRUE);
mysql.query;
#result = dbSendQuery(mysql.connection, mysql.query);
result = dbGetQuery(mysql.connection, mysql.query);
result;
radius.miles = 50;
my.latitude = result$latitude[1];
my.longitude = result$longitude[1];
delta.latitude = radius.miles / 68.703 ;
delta.longitude = radius.miles / (69.172 * cos(deg2rad(my.longitude)));
# 4 sides of the square ... CREATE A BOUNDING BOX
latitude.lower = my.latitude - delta.latitude;
latitude.upper = my.latitude + delta.latitude;
longitude.lower = my.longitude - delta.longitude;
longitude.upper = my.longitude + delta.longitude;
## longitude signs are opposite of latitude, would that be different outside US?
mysql.query.template = "SELECT * FROM {tablename} WHERE latitude > {latitude.lower} AND latitude < {latitude.upper} AND longitude < {longitude.lower} AND longitude > {longitude.upper} ORDER BY zipcode ASC;";
mysql.query = gsub("{tablename}",db.table.zipcodes, mysql.query.template, fixed=TRUE);
mysql.query = gsub("{zipcode}",zipcode, mysql.query, fixed=TRUE);
mysql.query = gsub("{latitude.lower}",latitude.lower, mysql.query, fixed=TRUE);
mysql.query = gsub("{latitude.upper}",latitude.upper, mysql.query, fixed=TRUE);
mysql.query = gsub("{longitude.lower}",longitude.lower, mysql.query, fixed=TRUE);
mysql.query = gsub("{longitude.upper}",longitude.upper, mysql.query, fixed=TRUE);
mysql.query;
result.neighbors = dbGetQuery(mysql.connection, mysql.query);
mysql.connection = dbConnect(RMySQL::MySQL(),
user = db.user,
password = db.passwd,
dbname = db.name ,
host = db.host);
result.neighbors = dbGetQuery(mysql.connection, mysql.query);
result.neighbors;
result.neighbors$distance <- conv_unit(  distm( x = result.neighbors[, 3:2], y = result[,3:2], fun=distGeo),  "m", "mi"); # meters to miles
result.neighbors <- result.neighbors %>% mutate(incircle = ifelse(distance > radius.miles, FALSE, TRUE))
result.neighbors
result.neighbors <- result.neighbors %>% mutate(incircle = ifelse(distance > "radius.miles", FALSE, TRUE))
result.neighbors
result.neighbors <- result.neighbors %>% mutate(incircle = ifelse(distance > radius.miles, FALSE, TRUE))
result.neighbors
result.neighbors <- filter(result.neighbors, incircle == TRUE)
result.neighbors
library(RecordLinkage); # install.packages("RecordLinkage", dependencies=TRUE);
w1.singular = "TRIANGLE";     sort( unlist(strsplit(w1.singular,"",fixed=TRUE)) );
w1 = "TRIANGLES";             sort( unlist(strsplit(w1,"",fixed=TRUE)) );
w2 = "GNARLIEST";             sort( unlist(strsplit(w2,"",fixed=TRUE)) );
w3 = "RESLATING";             sort( unlist(strsplit(w3,"",fixed=TRUE)) );
# the number returned is bound between [0,1]
jarowinkler(w1.singular, w1);
jarowinkler(w1.singular, w2);
jarowinkler(w1.singular, w3);
jarowinkler(w1, w2);
jarowinkler(w1, w3);
levenshteinSim(w1.singular, w1);
levenshteinSim(w1.singular, w2);
levenshteinSim(w1.singular, w3);
levenshteinSim(w1, w2);
levenshteinSim(w1, w3);
levenshteinDist(w1.singular, w1);
levenshteinDist(w1.singular, w2);
levenshteinDist(w1.singular, w3);
levenshteinDist(w1, w2);
levenshteinDist(w1, w3);
?strsplit
w1.singular = "TRIANGLE";     sort( unlist(strsplit(w1.singular,"",fixed=TRUE)) );
