for(i in 1:length.movies){
if(movies.50$ratings[i] <=5.6) {
movies.50$cluster.deciles[i] = 1;
count.1 = count.1+1;
} else if(movies.50$ratings[i] > 5.6 && movies.50$ratings[i] <= 6.0) {
movies.50$cluster.deciles[i] =2;
count.2 = count.2+1;
} else if(movies.50$ratings[i] > 6 && movies.50$ratings[i] <= 6.3){
movies.50$cluster.deciles=3;
count.3 = count.3+1;
} else if(movies.50$ratings[i] > 6.3 && movies.50$ratings[i] <= 6.6) {
movies.50$cluster.deciles=4;
count.4 = count.4+1;
} else if(movies.50$ratings[i] > 6.6 && movies.50$ratings[i] <= 6.7) {
movies.50$cluster.deciles=5;
count.5 = count.5+1;
} else if(movies.50$ratings[i] > 6.7 && movies.50$ratings[i] <= 6.8) {
movies.50$cluster.deciles=6;
count.6 = count.6+1;
} else if(movies.50$ratings[i] > 6.8 && movies.50$ratings[i] <= 7.1) {
movies.50$cluster.deciles=7;
count.7 = count.7+1;
} else if(movies.50$ratings[i] > 7.1 && movies.50$ratings[i] <= 7.3) {
movies.50$cluster.deciles=8;
count.8 = count.8+1;
} else if(movies.50$ratings[i] > 7.3 && movies.50$ratings[i] <= 7.6) {
movies.50$cluster.deciles=9;
count.9 = count.9+1;
} else if(movies.50$ratings[i] > 7.6) {
movies.50$cluster.deciles=10;
count.10 = count.10+1;
}
count = c(count.1, count.2, count.3, count.4, count.5, count.6, count.7, count.8, count.9, count.10);
quantile = c(1:10);
table = table(quantile, count);
table;
}
movies.50$cluster.deciles
movies.50$ratings[1]
movies.50$cluster.deciles
View(movies.50)
movies.50$cluster.deciles = NA;
for(i in 1:length.movies){
if(movies.50$ratings[i] <=5.6) {
movies.50$cluster.deciles[i] = 1;
count.1 = count.1+1;
} else if(movies.50$ratings[i] > 5.6 && movies.50$ratings[i] <= 6.0) {
movies.50$cluster.deciles[i] =2;
count.2 = count.2+1;
} else if(movies.50$ratings[i] > 6 && movies.50$ratings[i] <= 6.3){
movies.50$cluster.deciles=3;
count.3 = count.3+1;
} else if(movies.50$ratings[i] > 6.3 && movies.50$ratings[i] <= 6.6) {
movies.50$cluster.deciles=4;
count.4 = count.4+1;
} else if(movies.50$ratings[i] > 6.6 && movies.50$ratings[i] <= 6.7) {
movies.50$cluster.deciles=5;
count.5 = count.5+1;
} else if(movies.50$ratings[i] > 6.7 && movies.50$ratings[i] <= 6.8) {
movies.50$cluster.deciles=6;
count.6 = count.6+1;
} else if(movies.50$ratings[i] > 6.8 && movies.50$ratings[i] <= 7.1) {
movies.50$cluster.deciles=7;
count.7 = count.7+1;
} else if(movies.50$ratings[i] > 7.1 && movies.50$ratings[i] <= 7.3) {
movies.50$cluster.deciles=8;
count.8 = count.8+1;
} else if(movies.50$ratings[i] > 7.3 && movies.50$ratings[i] <= 7.6) {
movies.50$cluster.deciles=9;
count.9 = count.9+1;
} else if(movies.50$ratings[i] > 7.6) {
movies.50$cluster.deciles=10;
count.10 = count.10+1;
}
count = c(count.1, count.2, count.3, count.4, count.5, count.6, count.7, count.8, count.9, count.10);
quantile = c(1:10);
table = table(quantile, count);
table;
}
table
for(i in 1:length.movies){
if(movies.50$ratings[i] <=5.6) {
movies.50$cluster.deciles[i] = 1;
count.1 = count.1+1;
} else if(movies.50$ratings[i] > 5.6 && movies.50$ratings[i] <= 6.0) {
movies.50$cluster.deciles[i] =2;
count.2 = count.2+1;
} else if(movies.50$ratings[i] > 6 && movies.50$ratings[i] <= 6.3){
movies.50$cluster.deciles=3;
count.3 = count.3+1;
} else if(movies.50$ratings[i] > 6.3 && movies.50$ratings[i] <= 6.6) {
movies.50$cluster.deciles=4;
count.4 = count.4+1;
} else if(movies.50$ratings[i] > 6.6 && movies.50$ratings[i] <= 6.7) {
movies.50$cluster.deciles=5;
count.5 = count.5+1;
} else if(movies.50$ratings[i] > 6.7 && movies.50$ratings[i] <= 6.8) {
movies.50$cluster.deciles=6;
count.6 = count.6+1;
} else if(movies.50$ratings[i] > 6.8 && movies.50$ratings[i] <= 7.1) {
movies.50$cluster.deciles=7;
count.7 = count.7+1;
} else if(movies.50$ratings[i] > 7.1 && movies.50$ratings[i] <= 7.3) {
movies.50$cluster.deciles=8;
count.8 = count.8+1;
} else if(movies.50$ratings[i] > 7.3 && movies.50$ratings[i] <= 7.6) {
movies.50$cluster.deciles=9;
count.9 = count.9+1;
} else if(movies.50$ratings[i] > 7.6) {
movies.50$cluster.deciles=10;
count.10 = count.10+1;
}
count = c(count.1, count.2, count.3, count.4, count.5, count.6, count.7, count.8, count.9, count.10);
quantile = c(1:10);
table = as.data.frame(cbind(quantile, count));
table;
}
table
movies.50$cluster.deciles
table;
View(movies.50)
for(i in 1:length.movies){
if(movies.50$ratings[i] <=5.6) {
movies.50$cluster.deciles[i] = 1;
count.1 = count.1+1;
} else if(movies.50$ratings[i] > 5.6 && movies.50$ratings[i] <= 6.0) {
movies.50$cluster.deciles[i] =2;
count.2 = count.2+1;
} else if(movies.50$ratings[i] > 6 && movies.50$ratings[i] <= 6.3){
movies.50$cluster.deciles=3;
count.3 = count.3+1;
} else if(movies.50$ratings[i] > 6.3 && movies.50$ratings[i] <= 6.6) {
movies.50$cluster.deciles=4;
count.4 = count.4+1;
} else if(movies.50$ratings[i] > 6.6 && movies.50$ratings[i] <= 6.7) {
movies.50$cluster.deciles=5;
count.5 = count.5+1;
} else if(movies.50$ratings[i] > 6.7 && movies.50$ratings[i] <= 6.8) {
movies.50$cluster.deciles=6;
count.6 = count.6+1;
} else if(movies.50$ratings[i] > 6.8 && movies.50$ratings[i] <= 7.1) {
movies.50$cluster.deciles=7;
count.7 = count.7+1;
} else if(movies.50$ratings[i] > 7.1 && movies.50$ratings[i] <= 7.3) {
movies.50$cluster.deciles=8;
count.8 = count.8+1;
} else if(movies.50$ratings[i] > 7.3 && movies.50$ratings[i] <= 7.6) {
movies.50$cluster.deciles=9;
count.9 = count.9+1;
} else if(movies.50$ratings[i] > 7.6) {
movies.50$cluster.deciles=10;
count.10 = count.10+1;
}
}
View(movies.50)
str(movies.50);
length.movies = length(movies.50$cluster.deciles);
length.movies = length(movies.50$cluster.deciles);
count.1 = 0;
count.2 = 0;
count.3 = 0;
count.4 = 0;
count.5 = 0;
count.6 = 0;
count.7 = 0;
count.8 = 0;
count.9 = 0;
count.10= 0;
for(i in 1:length.movies){
if(movies.50$ratings[i] <=5.6) {
movies.50$cluster.deciles[i] = 1;
count.1 = count.1+1;
} else if(movies.50$ratings[i] > 5.6 && movies.50$ratings[i] <= 6.0) {
movies.50$cluster.deciles[i] =2;
count.2 = count.2+1;
} else if(movies.50$ratings[i] > 6 && movies.50$ratings[i] <= 6.3){
movies.50$cluster.deciles=3;
count.3 = count.3+1;
} else if(movies.50$ratings[i] > 6.3 && movies.50$ratings[i] <= 6.6) {
movies.50$cluster.deciles=4;
count.4 = count.4+1;
} else if(movies.50$ratings[i] > 6.6 && movies.50$ratings[i] <= 6.7) {
movies.50$cluster.deciles=5;
count.5 = count.5+1;
} else if(movies.50$ratings[i] > 6.7 && movies.50$ratings[i] <= 6.8) {
movies.50$cluster.deciles=6;
count.6 = count.6+1;
} else if(movies.50$ratings[i] > 6.8 && movies.50$ratings[i] <= 7.1) {
movies.50$cluster.deciles=7;
count.7 = count.7+1;
} else if(movies.50$ratings[i] > 7.1 && movies.50$ratings[i] <= 7.3) {
movies.50$cluster.deciles=8;
count.8 = count.8+1;
} else if(movies.50$ratings[i] > 7.3 && movies.50$ratings[i] <= 7.6) {
movies.50$cluster.deciles=9;
count.9 = count.9+1;
} else if(movies.50$ratings[i] > 7.6) {
movies.50$cluster.deciles=10;
count.10 = count.10+1;
}
}
length.movies = length(movies.50$cluster.deciles);
count.1 = 0;
count.2 = 0;
count.3 = 0;
count.4 = 0;
count.5 = 0;
count.6 = 0;
count.7 = 0;
count.8 = 0;
count.9 = 0;
count.10= 0;
for(i in 1:length.movies){
if(movies.50$ratings[i] <=5.6) {
movies.50$cluster.deciles[i] = 1;
count.1 = count.1+1;
} else if(movies.50$ratings[i] > 5.6 && movies.50$ratings[i] <= 6.0) {
movies.50$cluster.deciles[i] =2;
count.2 = count.2+1;
} else if(movies.50$ratings[i] > 6 && movies.50$ratings[i] <= 6.3){
movies.50$cluster.deciles=3;
count.3 = count.3+1;
} else if(movies.50$ratings[i] > 6.3 && movies.50$ratings[i] <= 6.6) {
movies.50$cluster.deciles=4;
count.4 = count.4+1;
} else if(movies.50$ratings[i] > 6.6 && movies.50$ratings[i] <= 6.7) {
movies.50$cluster.deciles=5;
count.5 = count.5+1;
} else if(movies.50$ratings[i] > 6.7 && movies.50$ratings[i] <= 6.8) {
movies.50$cluster.deciles=6;
count.6 = count.6+1;
} else if(movies.50$ratings[i] > 6.8 && movies.50$ratings[i] <= 7.1) {
movies.50$cluster.deciles=7;
count.7 = count.7+1;
} else if(movies.50$ratings[i] > 7.1 && movies.50$ratings[i] <= 7.3) {
movies.50$cluster.deciles=8;
count.8 = count.8+1;
} else if(movies.50$ratings[i] > 7.3 && movies.50$ratings[i] <= 7.6) {
movies.50$cluster.deciles=9;
count.9 = count.9+1;
} else if(movies.50$ratings[i] > 7.6) {
movies.50$cluster.deciles=10;
count.10 = count.10+1;
}
count = c(count.1, count.2, count.3, count.4, count.5, count.6, count.7, count.8, count.9, count.10);
quantile = c(1:10);
table = as.data.frame(cbind(quantile, count));
table;
}
table;
sum(table$count)
table;
movies.50$cluster.deciles = NA;
str(movies.50);
## you do something here ...
stats::quantile(movies.50$ratings, prob=seq(0.1,0.9,by=0.1), type=1 );
# (1) how many NA's are there ... keep them NA's
# 0 NAs in ratings
# (2) for the rest of the data, break it up into deciles
# (3) $cluster.deciles for a given movie should be NA, 1, 2, 3, ... 10
# (4) summarize how many movies live in each (table count)
length.movies = length(movies.50$cluster.deciles);
count.1 = 0;
count.2 = 0;
count.3 = 0;
count.4 = 0;
count.5 = 0;
count.6 = 0;
count.7 = 0;
count.8 = 0;
count.9 = 0;
count.10= 0;
for(i in 1:length.movies){
if(movies.50$ratings[i] <=5.6) {
movies.50$cluster.deciles[i] = 1;
count.1 = count.1+1;
} else if(movies.50$ratings[i] > 5.6 && movies.50$ratings[i] <= 6.0) {
movies.50$cluster.deciles[i] =2;
count.2 = count.2+1;
} else if(movies.50$ratings[i] > 6 && movies.50$ratings[i] <= 6.3){
movies.50$cluster.deciles=3;
count.3 = count.3+1;
} else if(movies.50$ratings[i] > 6.3 && movies.50$ratings[i] <= 6.6) {
movies.50$cluster.deciles=4;
count.4 = count.4+1;
} else if(movies.50$ratings[i] > 6.6 && movies.50$ratings[i] <= 6.7) {
movies.50$cluster.deciles=5;
count.5 = count.5+1;
} else if(movies.50$ratings[i] > 6.7 && movies.50$ratings[i] <= 6.8) {
movies.50$cluster.deciles=6;
count.6 = count.6+1;
} else if(movies.50$ratings[i] > 6.8 && movies.50$ratings[i] <= 7.1) {
movies.50$cluster.deciles=7;
count.7 = count.7+1;
} else if(movies.50$ratings[i] > 7.1 && movies.50$ratings[i] <= 7.3) {
movies.50$cluster.deciles=8;
count.8 = count.8+1;
} else if(movies.50$ratings[i] > 7.3 && movies.50$ratings[i] <= 7.6) {
movies.50$cluster.deciles=9;
count.9 = count.9+1;
} else if(movies.50$ratings[i] > 7.6) {
movies.50$cluster.deciles=10;
count.10 = count.10+1;
}
count = c(count.1, count.2, count.3, count.4, count.5, count.6, count.7, count.8, count.9, count.10);
quantile = c(1:10);
table = as.data.frame(cbind(quantile, count));
table;
}
table;
movies.50$cluster.deciles;
movies.50$cluster.deciles;
table;
Sys.setenv(WSU_SANDBOX_HOST = "md5.mshaffer.com");
Sys.setenv(WSU_SANDBOX_DATABASE = "wsu_sandbox_db");
Sys.setenv(WSU_SANDBOX_USER = "wsu_sandox_user");
Sys.setenv(WSU_SANDBOX_PASSWD = "!WSUCougars");
Sys.setenv(WSU_SANDBOX_HOST = "md5.mshaffer.com");
Sys.setenv(WSU_SANDBOX_DATABASE = "wsu_sandbox_db");
Sys.setenv(WSU_SANDBOX_USER = "wsu_sandox_user");
Sys.setenv(WSU_SANDBOX_PASSWD = "!WSUCougars");
Sys.setenv(WSU_SANDBOX_HOST = "md5.mshaffer.com");
Sys.setenv(WSU_SANDBOX_DATABASE = "wsu_sandbox_db");
Sys.setenv(WSU_SANDBOX_USER = "wsu_sandox_user");
Sys.setenv(WSU_SANDBOX_PASSWD = "!WSUCougars");
host = Sys.setenv(WSU_SANDBOX_HOST = "md5.mshaffer.com");
db = Sys.setenv(WSU_SANDBOX_DATABASE = "wsu_sandbox_db");
sys = Sys.setenv(WSU_SANDBOX_USER = "wsu_sandox_user");
sysp= Sys.setenv(WSU_SANDBOX_PASSWD = "!WSUCougars");
# copy/paste __student_access__/_SECRET_/_SECRET_database_.txt into console...  or this won't work
cfalls.latitude = 48.37028;
cfalls.longitude = -114.18889;
my.radius = 22; my.units = "mi"; #miles
# THIS is where these exam functions live ...
source( paste0(path.github,"misc/functions-midterm-F2000.R") );  # should be 2020 ... oh well
cfalls.info = getNeighborsFromLatLong(22, 48.37028, -114.18889, "mi");
cfalls.info$neighbors;
############## plotting ##############
brown = "#ffe4c4";
green = "#014421";
my.state = "montana";
my.state.color = "#ffe4c4";
my.county = "flathead";
my.county.color = "#014421";
##plot twist - i had to specify the maps package for each map function, otherwise I would get an error because my Rstudio was expecting inputs for the map() in the purrr library
plotNeighbors.2= function(info, state="montana", county="flathead",
state.color = "#ffe4c4", county.color = "#014421",
state.border = 0.05, county.border = 0.05,
nearby.states = c("idaho", "washington", "oregon"),
nearby.states.color = "white",
center.color = "yellow", center.pch=20, center.cex = 1.25,
inbox.color = "black", inbox.pch=20, inbox.cex = 1,
inradius.color = "white", inradius.pch=20, inradius.cex = 0.75,
box.color = "black", box.lwd = 2,
ellipse.color = "white", ellipse.pch=20, ellipse.cex = 0.25
)
{
state = tolower(state);
county = tolower(county);
nearby.states = tolower(nearby.states);
my.region = c(state, nearby.states);
region = maps::map('state', region=my.region, plot=FALSE);
state.idx = findAllIndexesWithValueInVector(region$names, state);
region.colors = rep(nearby.states.color, times=1+length(nearby.states));
region.colors[state.idx] = state.color;
### plot state with regional neighbor states
maps::map('state', region=my.region, col=region.colors,
plot = TRUE, fill = TRUE, myborder=state.border);
data(county.fips);
county.fip = county.fips$fips[
match( paste(state,county,sep=",") ,
county.fips$polyname)];
state.fips = county.fips$fips[
match( maps::map("county", state, plot=FALSE)$names,
county.fips$polyname) ];
state.colors = rep(state.color, times=length(state.fips) );
county.fip.idx = findAllIndexesWithValueInVector(state.fips, county.fip);
state.colors[county.fip.idx] = county.color;
### plot counties, highlighting this county of interest ...
maps::map('county', state, col=state.colors,
plot = TRUE, fill = TRUE, myborder=county.border);
### plot county of interest
maps::map('county', paste(state,county,sep=","),
col=county.color, bg=state.color,
plot = TRUE, fill = TRUE, myborder=county.border);
# flathead lake not found ...
# my.lakes = map("lakes", "montana,flathead", plot=FALSE);
### overlay center target point (star on map)
points( x = info$good.neighbors$longitude[1],
y = info$good.neighbors$latitude[1],
col=center.color, pch=center.pch, cex=center.cex);
### overlay bounding box
rect( info$box[4], info$box[1], info$box[3], info$box[2],
border = box.color, lwd = box.lwd );
### plot all candidates
points( x = info$copy.neighbors$longitude[-1],
y = info$copy.neighbors$latitude[-1],
col=inbox.color, pch=inbox.pch, cex=inbox.cex);
### overlay center target point (star on map)
points( x = info$good.neighbors$longitude[1],
y = info$good.neighbors$latitude[1],
col=center.color, pch=center.pch, cex=center.cex);
### plot all "good" candidates
points( x = info$good.neighbors$longitude[-1],
y = info$good.neighbors$latitude[-1],
col=inradius.color, pch=inradius.pch, cex=inradius.cex);
### box is not square due to "mercator" projections
# as a result, the circle will be an ellipse.  We have the center of the radius, and the radius.x and radius.y (by subtraction with the box data).
### EASTER EGG +5 ... overlay an ellipse to represent the "circle" region ...
### Since this is a midterm exam, this is available to everyone that gets it correct, not just the first person
##############################################################
# the code below sort-of works,
# https://stackoverflow.com/questions/41820683
# ellipse based on v box ...
# phi = 0;
# xc = info$good.neighbors$longitude[1];
# yc = info$good.neighbors$latitude[1];
# b = ( info$good.neighbors$latitude[1] - box[1]);
# a = ( box[3] - info$good.neighbors$longitude[1]);
#
# t <- seq(0, 2*pi, 0.01)
# x <- xc + a*cos(t)*cos(phi) - b*sin(t)*sin(phi);
# y <- yc + a*cos(t)*cos(phi) + b*sin(t)*cos(phi);
#
# points(x=x, y=y, col=ellipse.color, pch=ellipse.pch, cex=ellipse.cex);
}
plotNeighbors.2(cfalls.info,
state          = my.state,
state.color    = my.state.color,
state.border   = 0.05,
county         = my.county,
county.border   = 0.05,  # if you don't see the box, increase this to like 0.75
county.color   = my.county.color,
nearby.states  = my.nearby.states);
nsim = 50000;
y = 1:nsim;
ns = 0;
which = numeric(0);
for (i in y){
set.seed(i);
res = rbinom(n = 1, size = 1000, prob = 0.5);
if (res == 555) {
cat(i,sep = "\n");
ns = 1+ns;
which = c(which, i);
}
}
which;
ns;
nsim = 500000;
y = 1:nsim;
ns = 0;
which = numeric(0);
for (i in y){
set.seed(i);
res = rbinom(n = 1, size = 1000, prob = 0.5);
if (res == 555) {
cat(i,sep = "\n");
ns = 1+ns;
which = c(which, i);
}
}
which;
ns;
nsim = 500000;
y = 1:nsim;
x = 0;
which = numeric(0);
for (i in y){
set.seed(i);
res = rbinom(n = 1, size = 1000, prob = 0.5);
if (res == 555) {
cat(i,sep = "\n");
x = 1+x;
which = c(which, i);
}
}
which;
ns;
length(x);
nsim = 500000;
y = 1:nsim;
x = 0;
which = numeric(0);
for (i in y){
set.seed(i);
res = rbinom(n = 1, size = 1000, prob = 0.5);
if (res == 555) {
cat(i,sep = "\n");
x = 1+x;
which = c(which, i);
}
}
which;
length(x);
nsim = 500000;
y = 1:nsim;
ns = 0;
x = numeric(0);
for (i in y){
set.seed(i);
res = rbinom(n = 1, size = 1000, prob = 0.5);
if (res == 555) {
cat(i,sep = "\n");
ns = 1+ns;
x = c(x, i);
}
}
length(x);
set.seed(49771); rbinom(1,1000,0.5)
library(Hmisc); # p-values for correlation
high = subsetDataFrame(climate, c("key", "units"), "==", c("Record high F (C)",1));
