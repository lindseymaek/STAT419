measure.t = as.data.frame(d.t);
measure.t
dist(measure.t)
round( cor( measure.t ), digits=2);
Xs = scale(measure.t)
for(method in methods)
{
time.start = Sys.time();
X.hclust = hclust( dist(Xs), method=method);
plot(X.hclust);
time.end = Sys.time();
elapse = sprintf("%.3f", as.numeric(time.end) - as.numeric(time.start));
print(paste0(elapse, " secs to complete method ... ", method));
}
car.file = paste0(example.datasets.path,"MBA_CAR_ATTRIB.txt");
mba.cars = na.omit(read.table(car.file,na.strings='.'));
knitr::opts_chunk$set(echo = TRUE);
knitr::opts_chunk$set(warning = FALSE);
knitr::opts_chunk$set(message = FALSE);
## this should knit, but I am running some IMDB stuff
## so I wasn't able to verify a final Knit.
## please let me know in the Discussion Board if you
## find any errors, and I will fix
library(humanVerseWSU);
knitr::opts_chunk$set(echo = TRUE);
knitr::opts_chunk$set(warning = FALSE);
knitr::opts_chunk$set(message = FALSE);
## this should knit, but I am running some IMDB stuff
## so I wasn't able to verify a final Knit.
## please let me know in the Discussion Board if you
## find any errors, and I will fix
packageVersion("humanVerseWSU");  # ‘0.1.4’  [SHOULD BE THIS]
packageVersion("imdb");
# You need R tools for this to work:  https://cran.r-project.org/bin/windows/Rtools/
# You may want to see if you have the latest version...
# library(devtools);
# detach(package:humanVerseWSU);
install_github("MonteShaffer/imdb/imdb");
# You need R tools for this to work:  https://cran.r-project.org/bin/windows/Rtools/
# You may want to see if you have the latest version...
library(devtools);
# detach(package:humanVerseWSU);
install_github("MonteShaffer/imdb/imdb");
packageVersion("humanVerseWSU");  # ‘0.1.4’  [SHOULD BE THIS]
packageVersion("imdb");
library(humanVerseWSU);
getwd()
path.to.week7 = "/Users/lindseykornowske/.git/STAT419/WEEK-07";
path.graphics = paste0(path.to.week7,"graphics/");
createDirRecursive(path.graphics);
local.path = "/Users/lindseykornowske/.git/STAT419/datasets/";
protein = read.csv(paste0(local.path,"protein.csv"), sep = ",", header = T)
protein;
View(protein)
rows = protein$Country;
df = removeColumnsFromDataFrame(protein,"Country");
df.t = transposeMatrix(df);
colnames(df.t) = rows;
protein.t = as.data.frame(df.t);
protein.t;
X = removeColumnsFromDataFrame(protein,"Country");
rownames(X) = protein$Country;
# first a descriptive plot by country
stars(X, len = 0.5, key.loc=c(12,2), draw.segments = TRUE);
# stars need a better palette
palette(rainbow(12, s = 0.6, v = 0.75));
# redraw
stars(X, len = 0.5, key.loc=c(12,2), draw.segments = TRUE);
library(factoextra);   # install.packages("factoextra", dependencies=TRUE);
# this approach uses ggplot2 (not plot)
library(ggplot2);   # install.packages("ggplot2", dependencies=TRUE);
fviz_cluster(X.kmeans,data=X);
# for the faint of heart ...
X.kmeans = kmeans(X, 3);  # default algorithm
stars(X.kmeans$centers, len = 0.5, key.loc = c(4, 3),
main = "Algorithm: DEFAULT [Hartigan-Wong] \n Stars of KMEANS=3", draw.segments = TRUE);
print(X.kmeans);
membership = as.data.frame( matrix( X.kmeans$cluster, ncol=1)) ;
rownames(membership) = protein$Country;
membership;
print( table(membership) ) ;
stars(X.kmeans$centers, len = 0.5, key.loc = c(4, 3),
main = "Algorithm: DEFAULT [Hartigan-Wong] \n Stars of KMEANS=3", draw.segments = TRUE);
fviz_cluster(X.kmeans,data=X);
fviz_cluster(X.kmeans, data=X, geom="point");
# assumes the cluster is normal?
fviz_cluster(X.kmeans, data=X, geom="point", ellipse.type = "norm");
path.loop.graphics = paste0(path.graphics,"forloops/");
createDirRecursive(path.loop.graphics);
print(path.loop.graphics);
wss.png.list = c();
n.Countries = dim(X)[1];
n.Features = dim(X)[2];
K = 2:6;  # let's try these choices for our "k"
n.K = length(K);
algorithms = c("Hartigan-Wong", "Lloyd", "Forgy", "MacQueen");
n.A = length(algorithms);
membership = as.data.frame(
matrix(0, nrow=n.Countries, ncol=n.K*n.A) );
rownames(membership) = protein$Country;
m.col.names = c(); # don't know these yet ...
j=0;
for(algorithm in algorithms)
{
wss = numeric(n.K); # total within-sum-of-squares
times = numeric(n.K);
i = 0;
for(k in K)
{
print( paste0("algorithm: ", algorithm, " ",
paste0(rep("=",times=k),collapse=""), "> ",k));
j = 1 + j;
i = 1 + i;
time.start = Sys.time();
# I am appending to kmeans some previous results, so:
#X.kmeans = kmeans(X[,n.Features], k, algorithm=algorithm);
X.kmeans = kmeans(X, k, algorithm=algorithm);
# now for a "FOR LOOP ON STEROIDS"
# a variadic approach ...
path.loop.graphics = paste0(path.graphics,"forloops/");
createDirRecursive(path.loop.graphics);
print(path.loop.graphics);
# maybe open this folder before you run this code ...
wss.png.list = c();
n.Countries = dim(X)[1];
n.Features = dim(X)[2];
K = 2:6;  # let's try these choices for our "k"
n.K = length(K);
algorithms = c("Hartigan-Wong", "Lloyd", "Forgy", "MacQueen");
n.A = length(algorithms);
# a nested for loop, order matters, I want to study each algorithm as I loop over the special K's
membership = as.data.frame(
matrix(0, nrow=n.Countries, ncol=n.K*n.A) );
rownames(membership) = protein$Country;
m.col.names = c(); # don't know these yet ...
j=0;
for(algorithm in algorithms)
{
wss = numeric(n.K); # total within-sum-of-squares
times = numeric(n.K);
i = 0;
for(k in K)
{
print( paste0("algorithm: ", algorithm, " ",
paste0(rep("=",times=k),collapse=""), "> ",k));
j = 1 + j;
i = 1 + i;
time.start = Sys.time();
# I am appending to kmeans some previous results, so:
#X.kmeans = kmeans(X[,n.Features], k, algorithm=algorithm);
X.kmeans = kmeans(X, k, algorithm=algorithm);
# str(X.kmeans);
# key.loc probably needs to be adjusted per kmeans instance ... once you have a final answer, for your final writeup, you would really take the time to make the graph look perfect ... we are in a sandbox ... the "legend or key" may cover up one of your results.
stars(X.kmeans$centers, len = 0.5, key.loc = c(4, 3),
main = paste0("Algorithm: ", algorithm,
" \n Stars of KMEANS=",k), draw.segments = TRUE);
star.file = paste0(path.loop.graphics,"algo-", paste0(tolower(algorithm),collapse=""),"_k-",k,"_stars_.png");  # could also do PDF
################### writes image as png to file
png(star.file);
stars(X.kmeans$centers, len = 0.5, key.loc = c(4, 3),
main = paste0("Algorithm: ", algorithm,
" \n Stars of KMEANS=",k), draw.segments = TRUE);
dev.off();
###################
################### writes image as pdf to file
pdf( gsub(".png",".pdf",star.file, fixed=TRUE) );
stars(X.kmeans$centers, len = 0.5, key.loc = c(4, 3),
main = paste0("Algorithm: ", algorithm,
" \n Stars of KMEANS=",k), draw.segments = TRUE);
dev.off();
###################
# obviously, subfolders may help ... this is a demo ...
stars(X.kmeans$centers, len = 0.5, key.loc = c(4, 3),
main = paste0("Algorithm: ", algorithm,
" \n Stars of KMEANS=",k), draw.segments = TRUE);
# map of clusters back to countries
my.key = paste0(algorithm,".",k);
m.col.names = c(m.col.names, my.key);
membership[,j] = X.kmeans$cluster;
print( table(X.kmeans$cluster) ) ;
#plot(X, col=X.kmeans$cluster);
#points(X.kmeans$centers, col = 1:2, pch = 8, cex = 2);
time.end = Sys.time();
elapse = sprintf("%.3f",
as.numeric(time.end) - as.numeric(time.start));
# don't include this step in "timings" ... slows things down...
# rendering?
pca.clust.file = gsub("_stars_","_clusters_",star.file, fixed=TRUE);
################### writes image as png to file
png(pca.clust.file);
fviz_cluster(X.kmeans, data=X,
geom="point", ellipse.type = "norm");
dev.off();
###################
################### writes image as pdf to file
pdf( gsub(".png",".pdf",pca.clust.file, fixed=TRUE) );
fviz_cluster(X.kmeans, data=X,
geom="point", ellipse.type = "norm");
dev.off();
###################
print("fviz_cluster is not rendering inside of for loop");
fviz_cluster(X.kmeans, data=X,
geom="point", ellipse.type = "norm");
wss[i] = X.kmeans$tot.withinss;
times[i] = elapse;
}
#print(times);
#print(wss);
base::plot(K,times, main=paste0("[Deceptive] Time in seconds: ",algorithm), type="b"); # deceptive ... you need to run the code once, look at the ranges then rerun with valid ranges ...
# if you want to compare graphs visually, they should have the same axes.
# A good graph has a title, a xlab, a ylab
# Final writeup should have a nice caption for each image ...
base::plot(K,times, ylim=c(0, 0.1), main=paste0("Time in seconds: ",algorithm), type="b");
wss.file = paste0(path.graphics,"algo-", paste0(tolower(algorithm),collapse=""),"_k-",k,"_wss_.png"); # this is one folder up ...
wss.png.list = c(wss.png.list,wss.file);
################### writes image as png to file
png(wss.file);
base::plot(K,wss, ylim=c(0,3000), main=paste0("Total WSS: ",algorithm), type="b");
dev.off();
###################
################### writes image as pdf to file
pdf( gsub(".png",".pdf",wss.file, fixed=TRUE) );
base::plot(K,wss, ylim=c(0,3000), main=paste0("Total WSS: ",algorithm), type="b");
dev.off();
###################
# knitr will probably automate this process for us, more to follow: <https://www.r-bloggers.com/2014/01/fast-track-publishing-using-knitr-exporting-images-for-sharing-and-press-part-iii/>
# want to learn more about plot:  <https://statisticsglobe.com/plot-in-r-example>
}
colnames(membership) = m.col.names;
membership;
# rendering?  ... BUGGY ...
print("fviz_cluster renders outside of for loop");
k = 3; # my final answer?
X.kmeans = kmeans(X, k);
fviz_cluster(X.kmeans, data=X);
k = 4; # my final answer?
X.kmeans = kmeans(X, k);
fviz_cluster(X.kmeans, data=X);
# you may notice that it is changing cluster groups and boundaries at times ...
?pvclust
??pvclust
knitr::opts_chunk$set(echo = TRUE);
knitr::opts_chunk$set(warning = FALSE);
knitr::opts_chunk$set(message = FALSE);
library(humanVerseWSU);
path.to.week7 = "/Users/lindseykornowske/.git/STAT419/WEEK-07";
path.graphics = paste0(path.to.week7,"graphics/");
createDirRecursive(path.graphics);
local.path = "/Users/lindseykornowske/.git/STAT419/datasets/";
protein = read.csv(paste0(local.path,"protein.csv"), sep = ",", header = T)
protein;
rows = protein$Country;
df = removeColumnsFromDataFrame(protein,"Country");
df.t = transposeMatrix(df);
colnames(df.t) = rows;
protein.t = as.data.frame(df.t);
protein.t;
protein;
protein.t;
protein;
protein.t;
X = removeColumnsFromDataFrame(protein,"Country");
rownames(X) = protein$Country;
# first a descriptive plot by country
stars(X, len = 0.5, key.loc=c(12,2), draw.segments = TRUE);
# stars need a better palette
palette(rainbow(12, s = 0.6, v = 0.75));
# redraw
stars(X, len = 0.5, key.loc=c(12,2), draw.segments = TRUE);
# for the faint of heart ...
X.kmeans = kmeans(X, 3);  # default algorithm
stars(X.kmeans$centers, len = 0.5, key.loc = c(4, 3),
main = "Algorithm: DEFAULT [Hartigan-Wong] \n Stars of KMEANS=3", draw.segments = TRUE);
# for the faint of heart ...
X.kmeans = kmeans(X, 4);  # default algorithm
stars(X.kmeans$centers, len = 0.5, key.loc = c(4, 3),
main = "Algorithm: DEFAULT [Hartigan-Wong] \n Stars of KMEANS=3", draw.segments = TRUE);
print(X.kmeans);
membership = as.data.frame( matrix( X.kmeans$cluster, ncol=1)) ;
rownames(membership) = protein$Country;
membership;
path.loop.graphics = paste0(path.graphics,"forloops/");
createDirRecursive(path.loop.graphics);
print(path.loop.graphics);
wss.png.list = c();
n.Countries = dim(X)[1];
n.Features = dim(X)[2];
K = 2:6;  # let's try these choices for our "k"
n.K = length(K);
algorithms = c("Hartigan-Wong", "Lloyd", "Forgy", "MacQueen");
n.A = length(algorithms);
membership = as.data.frame(
matrix(0, nrow=n.Countries, ncol=n.K*n.A) );
rownames(membership) = protein$Country;
m.col.names = c(); # don't know these yet ...
j=0;
j=0;
for(algorithm in algorithms)
{
wss = numeric(n.K); # total within-sum-of-squares
times = numeric(n.K);
i = 0;
for(k in K)
{
print( paste0("algorithm: ", algorithm, " ",
paste0(rep("=",times=k),collapse=""), "> ",k));
j = 1 + j;
i = 1 + i;
time.start = Sys.time();
# I am appending to kmeans some previous results, so:
#X.kmeans = kmeans(X[,n.Features], k, algorithm=algorithm);
X.kmeans = kmeans(X, k, algorithm=algorithm);
# str(X.kmeans);
j=0;
}
for(algorithm in algorithms)
{
wss = numeric(n.K); # total within-sum-of-squares
times = numeric(n.K);
i = 0;
for(k in K)
{
print( paste0("algorithm: ", algorithm, " ",
paste0(rep("=",times=k),collapse=""), "> ",k));
j = 1 + j;
i = 1 + i;
time.start = Sys.time();
# I am appending to kmeans some previous results, so:
#X.kmeans = kmeans(X[,n.Features], k, algorithm=algorithm);
X.kmeans = kmeans(X, k, algorithm=algorithm);
# str(X.kmeans);
# key.loc probably needs to be adjusted per kmeans instance ... once you have a final answer, for your final writeup, you would really take the time to make the graph look perfect ... we are in a sandbox ... the "legend or key" may cover up one of your results.
stars(X.kmeans$centers, len = 0.5, key.loc = c(4, 3),
main = paste0("Algorithm: ", algorithm,
" \n Stars of KMEANS=",k), draw.segments = TRUE);
star.file = paste0(path.loop.graphics,"algo-", paste0(tolower(algorithm),collapse=""),"_k-",k,"_stars_.png");  # could also do PDF
################### writes image as png to file
png(star.file);
stars(X.kmeans$centers, len = 0.5, key.loc = c(4, 3),
main = paste0("Algorithm: ", algorithm,
" \n Stars of KMEANS=",k), draw.segments = TRUE);
dev.off();
###################
################### writes image as pdf to file
pdf( gsub(".png",".pdf",star.file, fixed=TRUE) );
stars(X.kmeans$centers, len = 0.5, key.loc = c(4, 3),
main = paste0("Algorithm: ", algorithm,
" \n Stars of KMEANS=",k), draw.segments = TRUE);
dev.off();
###################
# obviously, subfolders may help ... this is a demo ...
stars(X.kmeans$centers, len = 0.5, key.loc = c(4, 3),
main = paste0("Algorithm: ", algorithm,
" \n Stars of KMEANS=",k), draw.segments = TRUE);
# map of clusters back to countries
my.key = paste0(algorithm,".",k);
m.col.names = c(m.col.names, my.key);
membership[,j] = X.kmeans$cluster;
print( table(X.kmeans$cluster) ) ;
#plot(X, col=X.kmeans$cluster);
#points(X.kmeans$centers, col = 1:2, pch = 8, cex = 2);
time.end = Sys.time();
elapse = sprintf("%.3f",
as.numeric(time.end) - as.numeric(time.start));
# don't include this step in "timings" ... slows things down...
# rendering?
pca.clust.file = gsub("_stars_","_clusters_",star.file, fixed=TRUE);
################### writes image as png to file
png(pca.clust.file);
fviz_cluster(X.kmeans, data=X,
geom="point", ellipse.type = "norm");
dev.off();
###################
################### writes image as pdf to file
pdf( gsub(".png",".pdf",pca.clust.file, fixed=TRUE) );
fviz_cluster(X.kmeans, data=X,
geom="point", ellipse.type = "norm");
dev.off();
###################
print("fviz_cluster is not rendering inside of for loop");
fviz_cluster(X.kmeans, data=X,
geom="point", ellipse.type = "norm");
wss[i] = X.kmeans$tot.withinss;
times[i] = elapse;
}
#print(times);
#print(wss);
base::plot(K,times, main=paste0("[Deceptive] Time in seconds: ",algorithm), type="b"); # deceptive ... you need to run the code once, look at the ranges then rerun with valid ranges ...
# if you want to compare graphs visually, they should have the same axes.
# A good graph has a title, a xlab, a ylab
# Final writeup should have a nice caption for each image ...
base::plot(K,times, ylim=c(0, 0.1), main=paste0("Time in seconds: ",algorithm), type="b");
wss.file = paste0(path.graphics,"algo-", paste0(tolower(algorithm),collapse=""),"_k-",k,"_wss_.png"); # this is one folder up ...
wss.png.list = c(wss.png.list,wss.file);
################### writes image as png to file
png(wss.file);
base::plot(K,wss, ylim=c(0,3000), main=paste0("Total WSS: ",algorithm), type="b");
dev.off();
###################
################### writes image as pdf to file
pdf( gsub(".png",".pdf",wss.file, fixed=TRUE) );
base::plot(K,wss, ylim=c(0,3000), main=paste0("Total WSS: ",algorithm), type="b");
dev.off();
###################
# knitr will probably automate this process for us, more to follow: <https://www.r-bloggers.com/2014/01/fast-track-publishing-using-knitr-exporting-images-for-sharing-and-press-part-iii/>
# want to learn more about plot:  <https://statisticsglobe.com/plot-in-r-example>
}
j=0;
for(algorithm in algorithms)
{
wss = numeric(n.K); # total within-sum-of-squares
times = numeric(n.K);
i = 0;
for(k in K)
{
print( paste0("algorithm: ", algorithm, " ",
paste0(rep("=",times=k),collapse=""), "> ",k));
j = 1 + j;
i = 1 + i;
time.start = Sys.time();
# I am appending to kmeans some previous results, so:
#X.kmeans = kmeans(X[,n.Features], k, algorithm=algorithm);
X.kmeans = kmeans(X, k, algorithm=algorithm);
# str(X.kmeans);
# key.loc probably needs to be adjusted per kmeans instance ... once you have a final answer, for your final writeup, you would really take the time to make the graph look perfect ... we are in a sandbox ... the "legend or key" may cover up one of your results.
stars(X.kmeans$centers, len = 0.5, key.loc = c(4, 3),
main = paste0("Algorithm: ", algorithm,
" \n Stars of KMEANS=",k), draw.segments = TRUE);
star.file = paste0(path.loop.graphics,"algo-", paste0(tolower(algorithm),collapse=""),"_k-",k,"_stars_.png");  # could also do PDF
################### writes image as png to file
png(star.file);
stars(X.kmeans$centers, len = 0.5, key.loc = c(4, 3),
main = paste0("Algorithm: ", algorithm,
" \n Stars of KMEANS=",k), draw.segments = TRUE);
dev.off();
###################
################### writes image as pdf to file
pdf( gsub(".png",".pdf",star.file, fixed=TRUE) );
stars(X.kmeans$centers, len = 0.5, key.loc = c(4, 3),
main = paste0("Algorithm: ", algorithm,
" \n Stars of KMEANS=",k), draw.segments = TRUE);
dev.off();
###################
# obviously, subfolders may help ... this is a demo ...
stars(X.kmeans$centers, len = 0.5, key.loc = c(4, 3),
main = paste0("Algorithm: ", algorithm,
" \n Stars of KMEANS=",k), draw.segments = TRUE);
# map of clusters back to countries
my.key = paste0(algorithm,".",k);
m.col.names = c(m.col.names, my.key);
membership[,j] = X.kmeans$cluster;
print( table(X.kmeans$cluster) ) ;
#plot(X, col=X.kmeans$cluster);
#points(X.kmeans$centers, col = 1:2, pch = 8, cex = 2);
time.end = Sys.time();
elapse = sprintf("%.3f",
as.numeric(time.end) - as.numeric(time.start));
# don't include this step in "timings" ... slows things down...
# rendering?
pca.clust.file = gsub("_stars_","_clusters_",star.file, fixed=TRUE);
################### writes image as png to file
png(pca.clust.file);
fviz_cluster(X.kmeans, data=X,
geom="point", ellipse.type = "norm");
dev.off();
###################
################### writes image as pdf to file
pdf( gsub(".png",".pdf",pca.clust.file, fixed=TRUE) );
fviz_cluster(X.kmeans, data=X,
geom="point", ellipse.type = "norm");
dev.off();
###################
print("fviz_cluster is not rendering inside of for loop");
fviz_cluster(X.kmeans, data=X,
geom="point", ellipse.type = "norm");
wss[i] = X.kmeans$tot.withinss;
times[i] = elapse;
}
#print(times);
#print(wss);
base::plot(K,times, main=paste0("[Deceptive] Time in seconds: ",algorithm), type="b"); # deceptive ... you need to run the code once, look at the ranges then rerun with valid ranges ...
# if you want to compare graphs visually, they should have the same axes.
# A good graph has a title, a xlab, a ylab
# Final writeup should have a nice caption for each image ...
base::plot(K,times, ylim=c(0, 0.1), main=paste0("Time in seconds: ",algorithm), type="b");
wss.file = paste0(path.graphics,"algo-", paste0(tolower(algorithm),collapse=""),"_k-",k,"_wss_.png"); # this is one folder up ...
wss.png.list = c(wss.png.list,wss.file);
################### writes image as png to file
png(wss.file);
base::plot(K,wss, ylim=c(0,3000), main=paste0("Total WSS: ",algorithm), type="b");
dev.off();
###################
################### writes image as pdf to file
pdf( gsub(".png",".pdf",wss.file, fixed=TRUE) );
base::plot(K,wss, ylim=c(0,3000), main=paste0("Total WSS: ",algorithm), type="b");
dev.off();
###################
# knitr will probably automate this process for us, more to follow: <https://www.r-bloggers.com/2014/01/fast-track-publishing-using-knitr-exporting-images-for-sharing-and-press-part-iii/>
# want to learn more about plot:  <https://statisticsglobe.com/plot-in-r-example>
}
colnames(membership) = m.col.names;
membership;
# rendering?  ... BUGGY ...
print("fviz_cluster renders outside of for loop");
k = 3; # my final answer?
X.kmeans = kmeans(X, k);
fviz_cluster(X.kmeans, data=X);
k = 4; # my final answer?
X.kmeans = kmeans(X, k);
fviz_cluster(X.kmeans, data=X);
k = 4; # my final answer?
View(k)
