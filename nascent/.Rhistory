myfile = myfiles$testing[[d]][r];  # remember 0 is index 10
res = predictDigit(myfile,X.eigen);
row = c(d, unlist(res));
result[i,] = row;
i = 1 + i;
}
}
result;
}
result = as.data.frame( performClassification(myfiles,X.eigen) );
result;
library(DescTools);
install.packages("DescTools")
img.eigen[["values"]]
library(DescTools);
percent.mean = sum(result$true == result$mean) / nrow(result); # percentage correct %
percent.mean;
# CONFUSION MATRIX
# Conf(x = result$true, ref = result$mean);
library(DescTools);
percent.median = sum(result$true == result$median) / nrow(result); # percentage correct %
percent.median;
# CONFUSION MATRIX
# Conf(x = result$true, ref = result$median);
library(DescTools);
percent.top1 = sum(result$true == result$top1) / nrow(result); # percentage correct %
percent.top1;
# CONFUSION MATRIX
# Conf(x = result$true, ref = result$top1);
library(DescTools);
percent.sum3 = sum(result$true == result$sum3) / nrow(result); # percentage correct %
percent.sum3;
# CONFUSION MATRIX
# Conf(x = result$true, ref = result$sum3, pos=10);
percents = c(percent.mean, percent.median, percent.top1, percent.sum3);
percents;
# let's loop over the data, and store the "truth" with decisions based on various independent and joint rules ...
# wrap above code into a single function
predictDigit = function(myfile, X.eigen)
{
img.png = paste0(path.to.nascent,myfile);
img.matrix = getMatrixFromImage(img.png);
img.eigen = Re( eigen(img.matrix)$values );
## Let's use REAL only
compare = round( cosine( Re(img.eigen), Re(X.eigen) ), 2);
compare.matrix = matrix(compare, ncol=4, byrow=TRUE);
rownames(compare.matrix) = c(1:9,0);
colnames(compare.matrix) = letters[1:4];
compare.df = as.data.frame(compare.matrix);
compare.df$top1  = computeTop(compare.df[,1:4], 1, "sum");
compare.df$mean = rowMeans(compare.df[,1:4]);
compare.df$median =  rowMedians(compare.df[,1:4],"default");
ncs = ncol(compare.df);
decide = rowSums(compare.df[,5:ncs]);
# could we get ties here?
decide.max.idx = whichMax(decide);
# for ties, we will let "which.max" decide
list( "mean" = as.numeric(which.max(compare.df[,6])),
"median" = as.numeric(which.max(compare.df[,7])),
"top1" = as.numeric(which.max(compare.df[,5])),
"sum3" = decide.max.idx[1]);
}
performClassification = function(myfiles, X.eigen)
{
n = length(myfiles$testing);
m = length(myfiles$testing[[1]]); # we assume equal length
total = n * m;
# algos:  mean, median, top-1, [all-3] ... 4
result = matrix(NA, nrow=total, ncol=5);
colnames(result) = c("true", "mean", "median", "top1", "sum3");
i = 1;
for(d in 1:n) # true digit
{
for(r in 1:m) # replicate
{
myfile = myfiles$testing[[d]][r];  # remember 0 is index 10
res = predictDigit(myfile,X.eigen);
row = c(d, unlist(res));
result[i,] = row;
i = 1 + i;
}
}
result;
}
result = as.data.frame( performClassification(myfiles,X.eigen) );
result;
library(devtools);
library(humanVerseWSU);
path.github = "https://raw.githubusercontent.com/MonteShaffer/humanVerseWSU/master/";
include.me = paste0(path.github, "misc/functions-mnist.R");
source_url( include.me );
include.me = paste0(path.github, "humanVerseWSU/R/functions-encryption.R");
source_url( include.me );
path.to.nascent = "C:/Users/Alexander Nevsky/Dropbox/WSU-419/Fall 2020/__student_access__/unit_02_confirmatory_data_analysis/nascent/";
folder.mnist = "mnist-png/";
path.to.mnist = paste0(path.to.nascent, folder.mnist);
training.files = mnist.grabFiles("training",
path.to.mnist, folder.mnist);
library(devtools);
library(humanVerseWSU);
path.github = "/Users/lindseykornowske/.git/STAT419/nascent/";
include.me = paste0(path.github, "misc/functions-mnist.R");
source_url( include.me );
library(devtools);
library(humanVerseWSU);
path.github = "https://raw.githubusercontent.com/MonteShaffer/humanVerseWSU/master/";
include.me = paste0(path.github, "misc/functions-mnist.R");
source_url( include.me );
include.me = paste0(path.github, "humanVerseWSU/R/functions-encryption.R");
source_url( include.me );
path.to.nascent = "/Users/lindseykornowske/.git/STAT419/nascent/";
folder.mnist = "mnist-png/";
path.to.mnist = paste0(path.to.nascent, folder.mnist);
training.files = mnist.grabFiles("training",
path.to.mnist, folder.mnist);
n = length(training.files);
m = length(training.files[[1]]); # we assume balanced panel
total = n * m;
info.cols = c("number.letter","n","m", "rows.with.data", "cols.with.data");
result = as.data.frame( matrix(0,
nrow=total, ncol= length(info.cols) ) );
colnames(result) = info.cols;
result$number.letter = "";
i = 1;
for(d in 1:n) # true digit
{
num = d; if(num == 10) { num = 0; }
for(r in 1:m) # replicate
{
img.file = training.files[[d]][r];
img.matrix = mnist.grabMatrixFromImage(img.file,
path.to.nascent);
img.matrix.rs = rowSums(img.matrix);
img.matrix.cs = colSums(img.matrix);
result[i,]$number.letter = paste0(num,"-",letters[r]);
result[i,]$n = d;
result[i,]$m = r;
result[i,]$rows.with.data = sum(img.matrix.rs > 0);
result[i,]$cols.with.data = sum(img.matrix.cs > 0);
i = 1 + i;
}
}
result;
max(result$rows.with.data);
max(result$cols.with.data);
img.file = training.files[[7]][3];  ### maybe rotate "8"s?
img.matrix = mnist.grabMatrixFromImage(img.file,
path.to.nascent);
im.printImageMatrix(img.matrix);
#im.printImageMatrix(img.matrix);
dim(img.matrix);
img.matrix.t = mnist.trimMatrix(img.matrix);
im.printImageMatrix(img.matrix.t);
dim(img.matrix.t);
img.matrix.c = mnist.centerMatrix(img.matrix, c(24,24)); # this may truncate "as-is"
im.printImageMatrix(img.matrix.c, 2); # split into sub-grids
im.printImageMatrix(img.matrix.c, 3);
im.printImageMatrix(img.matrix.c, 3, raw=TRUE);
im.printImageMatrix(img.matrix.c, 3, raw=TRUE, raw.r="I");
# numbers are 0.1 = 1; 0.2 = 2; ... 1.0 = "X"
dim(img.matrix.c);
# we could have the options in nested keys or a paste0 flat key.  Either way, we will have some for loops
option = list();
option$matrix.size        = c("raw", "24x24");
#option$matrix.size = c("24x24");
option$data.form          = c("b", "c");   # c("binary", "continuous");
#option$data.form = c("c");
option$matrix.division    = c(1,2,3,4,6);
#option$matrix.division = c(3);
# this option is currently hardcoded ...
option$matrix.features    = c("eigen", "eigen.half", "eigen.fourth", "eigen.third", "eigen.sixth",  "gridcount", "rowsums", "colsums");
#option$matrix.features = c("gridcount");
option$comparison.methods = c("sim.cosine","dist.euclidean");
option$decision.stats     = c("mean", "median", "sd", "median+sd", "top^1", "top^2", "top^3", "top^4", "top^5", "top^1+mean+median+sd", "top^1+mean+median", "top^1+mean", "top^1+median", "top^2+mean+median+sd", "top^2+mean+median", "top^2+mean", "top^2+median", "top^3+mean+median+sd", "top^3+mean+median", "top^3+mean", "top^3+median");  # ideal if this is odd for a final-decision
# option$decision.stats = c("top^1");
training.data = mnist.prepareTrainingData(training.files,
path.to.mnist, folder.mnist, option);
# Cntrl + Alt + I ... # Thanks, Nathan
testing.files = mnist.grabFiles("testing",
path.to.mnist, folder.mnist);
# example of same preparation for a single "comparison" element
test.one = mnist.prepareOneTest(testing.files,
d=1, r=1,
path.to.mnist, folder.mnist, option);
result.one = mnist.performOneTest(testing.files, training.data,
d=2, r=2,
path.to.mnist, folder.mnist, option);
best.of.best =  whichMaxFreq(result.one$best);
best.of.best;
outcome.details = as.numeric(unlist(result.one[,6:length(result.one)]));
table(outcome.details);
whichMaxFreq(outcome.details);
# this will take awhile... we could divide the tests up into children processes and use multi-threads ...
## took about 300 seconds on my computer with "all options"
## so we cache it ...
final = mnist.performAllTest(testing.files, training.data,
path.to.mnist, folder.mnist, option);
# str(final); # we have the raw dataframe panel, true, and best.of.best
final.summary = mnist.resultSummary(final, option);
final.summary;
## matrix.size
sub = wildcardSearch( paste0("24x24",".*"), "data.id", df=final$data);
## data.form
sub = wildcardSearch( paste0("*.","c",".*"), "data.id", df=sub);
## matrix.division
sub = wildcardSearch( paste0("*.",3,"_*"), "data.id", df=sub);
## matrix.features
sub = wildcardSearch( paste0("*_","eigen.third"), "data.id", df=sub);
## comparison.methods
sub = subsetDataFrame( sub, "comparison.method", "==" , "sim.cosine");
## decision.stats
result = list();
pick.one = NULL;
for(decision.stats in option$decision.stats)
{
key.name = paste0("stats.",decision.stats);
name.idx = which(names(final$data) == key.name );
stats1 = sub[,c(1:2,name.idx)];
#test1 = sum(sub$true == sub$best) / nrow(sub);
test1 = sum(stats1[,1] == stats1[,3]) / nrow(stats1); # compare to individual test...
if(key.name == "stats.top^2+mean") { pick.one=stats1; }
result[[key.name]] = test1;
}
result;
pick.one;
## matrix.size
sub = wildcardSearch( paste0("24x24",".*"), "data.id", df=final$data);
View(sub)
View(mnist.resultSummary)
View(mnist.resultSummary)
## decision.stats
result = list();
pick.one = NULL;
for(decision.stats in option$decision.stats)
hi
result = list();
pick.one = NULL;
for(decision.stats in option$decision.stats)
{
key.name = paste0("stats.",decision.stats);
name.idx = which(names(final$data) == key.name );
stats1 = sub[,c(1:2,name.idx)];
test1 = sum(sub$true == sub$best) / nrow(sub);
#test1 = sum(stats1[,1] == stats1[,3]) / nrow(stats1); # compare to individual test...
if(key.name == "stats.top^2+mean") { pick.one=stats1; }
result[[key.name]] = test1;
}
result;
pick.one;
## decision.stats
result = list();
pick.one = NULL;
for(decision.stats in option$decision.stats)
{
key.name = paste0("stats.",decision.stats);
name.idx = which(names(final$data) == key.name );
stats1 = sub[,c(1:2,name.idx)];
#test1 = sum(sub$true == sub$best) / nrow(sub);
test1 = sum(stats1[,1] == stats1[,3]) / nrow(stats1); # compare to individual test...
if(key.name == "stats.top^2+mean") { pick.one=stats1; }
result[[key.name]] = test1;
}
result;
pick.one;
View(mnist.prepareTrainingData)
View(mnist.performOneTest)
View(mnist.performOneTest)
## matrix.size
sub = wildcardSearch( paste0("24x24",".*"), "data.id", df=final$data);
## data.form
sub = wildcardSearch( paste0("*.","c",".*"), "data.id", df=sub);
## matrix.division
sub = wildcardSearch( paste0("*.",2,"_*"), "data.id", df=sub);
## matrix.features
sub = wildcardSearch( paste0("*_","eigen.third"), "data.id", df=sub);
## comparison.methods
sub = subsetDataFrame( sub, "comparison.method", "==" , "sim.cosine");
## decision.stats
result = list();
pick.one = NULL;
for(decision.stats in option$decision.stats)
{
key.name = paste0("stats.",decision.stats);
name.idx = which(names(final$data) == key.name );
stats1 = sub[,c(1:2,name.idx)];
#test1 = sum(sub$true == sub$best) / nrow(sub);
test1 = sum(stats1[,1] == stats1[,3]) / nrow(stats1); # compare to individual test...
if(key.name == "stats.top^2+mean") { pick.one=stats1; }
result[[key.name]] = test1;
}
result;
pick.one;
## matrix.size
sub = wildcardSearch( paste0("24x24",".*"), "data.id", df=final$data);
## data.form
sub = wildcardSearch( paste0("*.","c",".*"), "data.id", df=sub);
## matrix.division
sub = wildcardSearch( paste0("*.",6,"_*"), "data.id", df=sub);
## matrix.features
sub = wildcardSearch( paste0("*_","eigen.third"), "data.id", df=sub);
## comparison.methods
sub = subsetDataFrame( sub, "comparison.method", "==" , "sim.cosine");
## decision.stats
result = list();
pick.one = NULL;
for(decision.stats in option$decision.stats)
{
key.name = paste0("stats.",decision.stats);
name.idx = which(names(final$data) == key.name );
stats1 = sub[,c(1:2,name.idx)];
#test1 = sum(sub$true == sub$best) / nrow(sub);
test1 = sum(stats1[,1] == stats1[,3]) / nrow(stats1); # compare to individual test...
if(key.name == "stats.top^2+mean") { pick.one=stats1; }
result[[key.name]] = test1;
}
result;
pick.one;
View(sub)
View(sub)
View(stats1)
View(option)
View(option)
## matrix.size
sub = wildcardSearch( paste0("24x24",".*"), "data.id", df=final$data);
## data.form
sub = wildcardSearch( paste0("*.","c",".*"), "data.id", df=sub);
## matrix.division
sub = wildcardSearch( paste0("*.",10,"_*"), "data.id", df=sub);
## matrix.features
sub = wildcardSearch( paste0("*_","eigen.third"), "data.id", df=sub);
## comparison.methods
sub = subsetDataFrame( sub, "comparison.method", "==" , "sim.cosine");
## decision.stats
result = list();
pick.one = NULL;
for(decision.stats in option$decision.stats)
{
key.name = paste0("stats.",decision.stats);
name.idx = which(names(final$data) == key.name );
stats1 = sub[,c(1:2,name.idx)];
#test1 = sum(sub$true == sub$best) / nrow(sub);
test1 = sum(stats1[,1] == stats1[,3]) / nrow(stats1); # compare to individual test...
if(key.name == "stats.top^2+mean") { pick.one=stats1; }
result[[key.name]] = test1;
}
result;
pick.one;
## matrix.size
sub = wildcardSearch( paste0("24x24",".*"), "data.id", df=final$data);
## data.form
sub = wildcardSearch( paste0("*.","c",".*"), "data.id", df=sub);
## matrix.division
sub = wildcardSearch( paste0("*.",9,"_*"), "data.id", df=sub);
## matrix.features
sub = wildcardSearch( paste0("*_","eigen.third"), "data.id", df=sub);
## comparison.methods
sub = subsetDataFrame( sub, "comparison.method", "==" , "sim.cosine");
## decision.stats
result = list();
pick.one = NULL;
for(decision.stats in option$decision.stats)
{
key.name = paste0("stats.",decision.stats);
name.idx = which(names(final$data) == key.name );
stats1 = sub[,c(1:2,name.idx)];
#test1 = sum(sub$true == sub$best) / nrow(sub);
test1 = sum(stats1[,1] == stats1[,3]) / nrow(stats1); # compare to individual test...
if(key.name == "stats.top^2+mean") { pick.one=stats1; }
result[[key.name]] = test1;
}
result;
pick.one;
## matrix.size
sub = wildcardSearch( paste0("24x24",".*"), "data.id", df=final$data);
## data.form
sub = wildcardSearch( paste0("*.","c",".*"), "data.id", df=sub);
## matrix.division
sub = wildcardSearch( paste0("*.",9,"_*"), "data.id", df=sub);
## matrix.features
sub = wildcardSearch( paste0("*_","eigen.third"), "data.id", df=sub);
## comparison.methods
sub = subsetDataFrame( sub, "comparison.method", "==" , "sim.cosine");
## decision.stats
result = list();
pick.one = NULL;
for(decision.stats in option$decision.stats)
{
key.name = paste0("stats.",decision.stats);
name.idx = which(names(final$data) == key.name );
stats1 = sub[,c(1:2,name.idx)];
#test1 = sum(sub$true == sub$best) / nrow(sub);
test1 = sum(stats1[,1] == stats1[,3]) / nrow(stats1); # compare to individual test...
if(key.name == "stats.top^2+mean") { pick.one=stats1; }
result[[key.name]] = test1;
}
result;
pick.one;
## matrix.size
sub = wildcardSearch( paste0("24x24",".*"), "data.id", df=final$data);
## data.form
sub = wildcardSearch( paste0("*.","c",".*"), "data.id", df=sub);
## matrix.division
sub = wildcardSearch( paste0("*.",1,"_*"), "data.id", df=sub);
## matrix.features
sub = wildcardSearch( paste0("*_","eigen.third"), "data.id", df=sub);
## comparison.methods
sub = subsetDataFrame( sub, "comparison.method", "==" , "sim.cosine");
## decision.stats
result = list();
pick.one = NULL;
for(decision.stats in option$decision.stats)
{
key.name = paste0("stats.",decision.stats);
name.idx = which(names(final$data) == key.name );
stats1 = sub[,c(1:2,name.idx)];
#test1 = sum(sub$true == sub$best) / nrow(sub);
test1 = sum(stats1[,1] == stats1[,3]) / nrow(stats1); # compare to individual test...
if(key.name == "stats.top^2+mean") { pick.one=stats1; }
result[[key.name]] = test1;
}
result;
pick.one;
## matrix.size
sub = wildcardSearch( paste0("24x24",".*"), "data.id", df=final$data);
## data.form
sub = wildcardSearch( paste0("*.","c",".*"), "data.id", df=sub);
## matrix.division
sub = wildcardSearch( paste0("*.",2,"_*"), "data.id", df=sub);
## matrix.features
sub = wildcardSearch( paste0("*_","eigen.third"), "data.id", df=sub);
## comparison.methods
sub = subsetDataFrame( sub, "comparison.method", "==" , "sim.cosine");
## decision.stats
result = list();
pick.one = NULL;
for(decision.stats in option$decision.stats)
{
key.name = paste0("stats.",decision.stats);
name.idx = which(names(final$data) == key.name );
stats1 = sub[,c(1:2,name.idx)];
#test1 = sum(sub$true == sub$best) / nrow(sub);
test1 = sum(stats1[,1] == stats1[,3]) / nrow(stats1); # compare to individual test...
if(key.name == "stats.top^2+mean") { pick.one=stats1; }
result[[key.name]] = test1;
}
result;
pick.one;
## matrix.size
sub = wildcardSearch( paste0("24x24",".*"), "data.id", df=final$data);
## data.form
sub = wildcardSearch( paste0("*.","c",".*"), "data.id", df=sub);
## matrix.division
sub = wildcardSearch( paste0("*.",3,"_*"), "data.id", df=sub);
## matrix.features
sub = wildcardSearch( paste0("*_","eigen.third"), "data.id", df=sub);
## comparison.methods
sub = subsetDataFrame( sub, "comparison.method", "==" , "sim.cosine");
## decision.stats
result = list();
pick.one = NULL;
for(decision.stats in option$decision.stats)
{
key.name = paste0("stats.",decision.stats);
name.idx = which(names(final$data) == key.name );
stats1 = sub[,c(1:2,name.idx)];
#test1 = sum(sub$true == sub$best) / nrow(sub);
test1 = sum(stats1[,1] == stats1[,3]) / nrow(stats1); # compare to individual test...
if(key.name == "stats.top^2+mean") { pick.one=stats1; }
result[[key.name]] = test1;
}
result;
pick.one;
## matrix.size
sub = wildcardSearch( paste0("24x24",".*"), "data.id", df=final$data);
## data.form
sub = wildcardSearch( paste0("*.","c",".*"), "data.id", df=sub);
## matrix.division
sub = wildcardSearch( paste0("*.",6,"_*"), "data.id", df=sub);
## matrix.features
sub = wildcardSearch( paste0("*_","eigen.third"), "data.id", df=sub);
## comparison.methods
sub = subsetDataFrame( sub, "comparison.method", "==" , "sim.cosine");
## decision.stats
result = list();
pick.one = NULL;
for(decision.stats in option$decision.stats)
{
key.name = paste0("stats.",decision.stats);
name.idx = which(names(final$data) == key.name );
stats1 = sub[,c(1:2,name.idx)];
#test1 = sum(sub$true == sub$best) / nrow(sub);
test1 = sum(stats1[,1] == stats1[,3]) / nrow(stats1); # compare to individual test...
if(key.name == "stats.top^2+mean") { pick.one=stats1; }
result[[key.name]] = test1;
}
result;
pick.one;
View(sub)
img.file = training.files[[7]][3];  ### maybe rotate "8"s?
img.matrix = mnist.grabMatrixFromImage(img.file,
path.to.nascent);
#im.printImageMatrix(img.matrix);
dim(img.matrix);
img.matrix.t = mnist.trimMatrix(img.matrix);
im.printImageMatrix(img.matrix.t);
dim(img.matrix.t);
img.matrix.c = mnist.centerMatrix(img.matrix, c(24,24)); # this may truncate "as-is"
im.printImageMatrix(img.matrix.c, 2); # split into sub-grids
im.printImageMatrix(img.matrix.c, 3);
im.printImageMatrix(img.matrix.c, 3, raw=TRUE);
im.printImageMatrix(img.matrix.c, 3, raw=TRUE, raw.r="I");
im.printImageMatrix(img.matrix.c,4);
